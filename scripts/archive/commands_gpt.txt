existing database
! schema for each tables
1. songs table
    song_id TEXT PRIMARY KEY,
    song_name TEXT,
    artist_ids TEXT,
    acousticness REAL,
    danceability REAL,
    energy REAL,
    instrumentalness REAL,
    key INTEGER,
    liveness REAL,
    loudness REAL,
    mode INTEGER,
    speechiness REAL,
    tempo REAL,
    time_signature INTEGER,
    valence REAL
2. playlists table
    playlist_id TEXT PRIMARY KEY,
    playlist_creator_id TEXT,
    playlist_original_items INTEGER,
    playlist_items_fetched INTEGER,
    playlist_top_artist_ids TEXT,
    playlist_top_genres TEXT,
    playlist_items TEXT,
    min_acousticness REAL,
    max_acousticness REAL,
    min_danceability REAL,
    max_danceability REAL,
    min_energy REAL,
    max_energy REAL,
    min_instrumentalness REAL,
    max_instrumentalness REAL,
    min_key INTEGER,
    max_key INTEGER,
    min_liveness REAL,
    max_liveness REAL,
    min_loudness REAL,
    max_loudness REAL,
    min_mode INTEGER,
    max_mode INTEGER,
    min_speechiness REAL,
    max_speechiness REAL,
    min_tempo REAL,
    max_tempo REAL,
    min_time_signature INTEGER,
    max_time_signature INTEGER,
    min_valence REAL,
    max_valence REAL
3. artists table
    artist_id TEXT PRIMARY KEY,
    artist_name TEXT,
    artist_genres TEXT


i want to continue making Collaborative Filtering song recommendation on my code 5BgnL6gHauuvxe4Ok6W1aC
1. gather playlists from get_playlists_by_song
2. gather playlists from get_playlists_by_artist
3. merge playlists and remove duplicated playlist_id
4. show playlist result on playlist section
5. show song result on song section

i want to write result from get_playlists_by_song, get_playlists_by_artist to the recommendation result
continue this code feel free to add new functions inside cf_functions()

RESULT FORMAT
# BEST PLAYLIST MATCH
1. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID
2. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID
# BEST SONGS MATCH
1. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres | Count: {N}
2. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres | Count: {N}

import sqlite3
import configparser
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from spotipy.exceptions import SpotifyException
import time
from collections import Counter
import logging

# Setup logging
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load configuration
config = configparser.ConfigParser()
config.read('config.cfg')

DB = config['rs']['db_path']
CLIENT_ID = config['api']['client_id']
CLIENT_SECRET = config['api']['client_secret']
DELAY_TIME = float(config['api']['delay_time'])
N_MINIMUM = int(config['rs']['n_minimum_playlist_songs'])
N_SCRAPE = int(config['rs']['n_scrape'])

# Spotify API credentials
client_credentials_manager = SpotifyClientCredentials(
    client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

# Connect to SQLite database
conn = sqlite3.connect(DB)
cursor = conn.cursor()
