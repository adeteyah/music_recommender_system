existing database
1. songs table
    song_id TEXT PRIMARY KEY,
    song_name TEXT,
    artist_ids TEXT,
    acousticness REAL,
    danceability REAL,
    energy REAL,
    instrumentalness REAL,
    key INTEGER,
    liveness REAL,
    loudness REAL,
    mode INTEGER,
    speechiness REAL,
    tempo REAL,
    time_signature INTEGER,
    valence REAL
2. playlists table
    playlist_id TEXT PRIMARY KEY,
    playlist_creator_id TEXT,
    playlist_original_items INTEGER,
    playlist_items_fetched INTEGER,
    playlist_top_artist_ids TEXT,
    playlist_top_genres TEXT,
    playlist_items TEXT,
    min_acousticness REAL,
    max_acousticness REAL,
    min_danceability REAL,
    max_danceability REAL,
    min_energy REAL,
    max_energy REAL,
    min_instrumentalness REAL,
    max_instrumentalness REAL,
    min_key INTEGER,
    max_key INTEGER,
    min_liveness REAL,
    max_liveness REAL,
    min_loudness REAL,
    max_loudness REAL,
    min_mode INTEGER,
    max_mode INTEGER,
    min_speechiness REAL,
    max_speechiness REAL,
    min_tempo REAL,
    max_tempo REAL,
    min_time_signature INTEGER,
    max_time_signature INTEGER,
    min_valence REAL,
    max_valence REAL
3. artists table
    artist_id TEXT PRIMARY KEY,
    artist_name TEXT,
    artist_genres TEXT

-- CF --
existing database
1. songs table
    song_id TEXT PRIMARY KEY,
    song_name TEXT,
    artist_ids TEXT,
2. playlists table
    playlist_id TEXT PRIMARY KEY,
    playlist_creator_id TEXT,
    playlist_top_genres TEXT,
    playlist_items TEXT, (array of song_id)
3. artists table
    artist_id TEXT PRIMARY KEY,
    artist_name TEXT,
    artist_genres TEXT (genres)

OUTPUT FORMAT
INPUTTED IDS (Inputted IDS are song_id)
1. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres
2. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres
3. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres
4. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres
5. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres
6. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres
7. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres

PLAYLIST CATEGORY (1,2,3,4,5<-array of playlist_id that has artist_id from inputted ids): {array of artists id} (Category Playlist that contains artists of inputted ids)
1. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID | Genres: {playlist_top_genres} | 88 songs from this playlist <- count how many songs in this playlist is filtered to the SONGS
2. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID | Genres: {playlist_top_genres} | 22 songs from this playlist

PLAYLIST CATEGORY: (6) {array of artist id} (Category Playlist that contains artists of inputted ids)
1. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID | Genres: {playlist_top_genres} | 63 songs from this playlist
2. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID | Genres: {playlist_top_genres} | 1 songs from this playlist

PLAYLIST CATEGORY: (7) {array of artist id} (Category Playlist that contains artists of inputted ids)
1. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID | Genres: {playlist_top_genres} | 1 songs from this playlist
2. https://open.spotify.com/playlist/playlist_id - https://open.spotify.com/user/Creator_ID | Genres: {playlist_top_genres} | 6 songs from this playlist

SONGS (Print songs from all playlists_result other than artist_id from the inputted ids)
1. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres | Count: {N <- count this song show up in playlists from PLAYLIST CATEGORY} | From:  {array of playlist id that contains this songs}
2. https://open.spotify.com/track/song_id artist_name - song_name | Genre: artist_genres | Count: {N <- count this song show up in playlists from PLAYLIST CATEGORY} | From:  {array of playlist id that contains this songs}

import sqlite3
import configparser

# Read configuration file
config = configparser.ConfigParser()
config.read('config.cfg')

MODEL = 'Collaborative Filtering'
DB = config['rs']['db_path']
OUTPUT_PATH = config['rs']['cbf_output']
N_RESULT = int(config['rs']['n_result'])

def get_song_info(conn, song_id):
    cursor = conn.cursor()
    cursor.execute("""
        SELECT s.song_id, s.song_name, s.artist_ids, a.artist_name, a.artist_genres
        FROM songs s
        JOIN artists a ON s.artist_ids = a.artist_id
        WHERE s.song_id = ?
    """, (song_id,))
    return cursor.fetchone()

#add procedural function here if needed

cf():
    conn = sqlite3.connect(DB)
    songs_info = read_inputted_ids(ids, conn)
    inputted_ids = set(id for id, *_ in songs_info)

    # print result to OUTPUT_PATH (.txt with utf-8 encoding)

    conn.close()
    print('Result for', MODEL, 'stored at', OUTPUT_PATH)
if __name__ == "__main__":
    ids = [
        '1BxfuPKGuaTgP7aM0Bbdwr',
        '4xqrdfXkTW4T0RauPLv3WA',
        '7JIuqL4ZqkpfGKQhYlrirs',
        '5dTHtzHFPyi8TlTtzoz1J9',
        '4cluDES4hQEUhmXj6TXkSo',
        '4ZtFanR9U6ndgddUvNcjcG',
        '2QjOHCTQ1Jl3zawyYOpxh6',
        '0nJW01T7XtvILxQgC5J7Wh',
        '7nQoDLkzCcoIpKPQt3eCdN',
        '72MEldEAmz3WMJ2MkII3kP',
    ]
    cf(ids)

-- CBF --
existing database
1. songs table
    song_id TEXT PRIMARY KEY,
    song_name TEXT,
    artist_ids TEXT,
    acousticness REAL,
    danceability REAL,
    energy REAL,
    instrumentalness REAL,
    key INTEGER,
    liveness REAL,
    loudness REAL,
    mode INTEGER,
    speechiness REAL,
    tempo REAL,
    time_signature INTEGER,
    valence REAL
2. playlists table
    playlist_id TEXT PRIMARY KEY,
    playlist_creator_id TEXT,
    playlist_top_genres TEXT,
    playlist_items TEXT, (array of song_id)
3. artists table
    artist_id TEXT PRIMARY KEY,
    artist_name TEXT,
    artist_genres TEXT (genres)

OUTPUT FORMAT
INPUTTED IDS (Inputted IDS are song_id)
1. https://open.spotify.com/track/song_id artist_name - song_name | acousticness: 0, and more
2. https://open.spotify.com/track/song_id artist_name - song_name | acousticness: 0, and more
3. https://open.spotify.com/track/song_id artist_name - song_name | acousticness: 0, and more
4. https://open.spotify.com/track/song_id artist_name - song_name | acousticness: 0, and more
5. https://open.spotify.com/track/song_id artist_name - song_name | acousticness: 0, and more
6. https://open.spotify.com/track/song_id artist_name - song_name | acousticness: 0, and more
7. https://open.spotify.com/track/song_id artist_name - song_name | acousticness: 0, and more
continue my code to print desired output
import sqlite3
import configparser

# Read configuration file
config = configparser.ConfigParser()
config.read('config.cfg')

MODEL = 'Content-based Filtering'
DB = config['rs']['db_path']
OUTPUT_PATH = config['rs']['cbf_output']
N_RESULT = int(config['rs']['n_result'])

def get_song_info(conn, song_id):
    cursor = conn.cursor()
    cursor.execute("""
        SELECT s.song_id, s.song_name, s.artist_ids, a.artist_name, a.artist_genres
        FROM songs s
        JOIN artists a ON s.artist_ids = a.artist_id
        WHERE s.song_id = ?
    """, (song_id,))
    return cursor.fetchone()

#add procedural function here if needed

cbf():
    conn = sqlite3.connect(DB)
    songs_info = read_inputted_ids(ids, conn)
    inputted_ids = set(id for id, *_ in songs_info)

    # print result to OUTPUT_PATH (.txt with utf-8 encoding)
    
    conn.close()
    print('Result for', MODEL, 'stored at', OUTPUT_PATH)
if __name__ == "__main__":
    ids = [
        '1BxfuPKGuaTgP7aM0Bbdwr',
        '4xqrdfXkTW4T0RauPLv3WA',
        '7JIuqL4ZqkpfGKQhYlrirs',
        '5dTHtzHFPyi8TlTtzoz1J9',
    ]
    cbf(ids)

-- CBF CF --
existing database
1. songs table
    song_id TEXT PRIMARY KEY,
    song_name TEXT,
    artist_ids TEXT,
2. playlists table
    playlist_id TEXT PRIMARY KEY,
    playlist_creator_id TEXT,
    playlist_top_genres TEXT,
    playlist_items TEXT, (array of song_id)
3. artists table
    artist_id TEXT PRIMARY KEY,
    artist_name TEXT,
    artist_genres TEXT (genres)

add new section after SIMILAR AUDIO FEATURES called "COLLECTING SIMILAR SONG PLAYLIST"
1. continue format from SIMILAR AUDIO FEATURES, collect similar songs
2. find playlists that has similar song id in column playlist_items
3. print playlist_id and Creator_ID | playlist_top_genres

import sqlite3
import configparser

# Read configuration file
config = configparser.ConfigParser()
config.read('config.cfg')

MODEL = 'Content-based Filtering - Collaborative Filtering'
DB = config['rs']['db_path']
OUTPUT_PATH = config['rs']['cbf_cf_output']
N_RESULT = int(config['rs']['n_result'])
CBF_FEATURES = config['rs']['cbf_features'].split(', ')
REAL_BOUND_VAL = float(config['rs']['cbf_real_bound'])
INTEGER_BOUND_VAL = int(config['rs']['cbf_integer_bound'])

# Define which features are integers
INTEGER_FEATURES = {'tempo', 'time_signature', 'key', 'mode'}


def get_song_info(conn, song_id, features):
    features_sql = ', '.join(features)
    query = f"""
        SELECT s.song_id, s.song_name, s.artist_ids, a.artist_name, a.artist_genres,
               {features_sql}
        FROM songs s
        JOIN artists a ON s.artist_ids = a.artist_id
        WHERE s.song_id = ?
    """
    cursor = conn.cursor()
    cursor.execute(query, (song_id,))
    return cursor.fetchone()


def read_inputted_ids(ids, conn, features):
    song_info_list = []
    for song_id in ids:
        song_info = get_song_info(conn, song_id, features)
        if song_info:
            song_info_list.append(song_info)
    return song_info_list


def calculate_similarity(song_features, input_features):
    return sum(abs(song_feature - input_feature) for song_feature, input_feature in zip(song_features, input_features))


def get_similar_audio_features(conn, features, input_audio_features, inputted_ids, inputted_songs):
    feature_conditions = []
    for i, feature in enumerate(features):
        feature_name = feature.split('.')[-1]
        lower_bound = input_audio_features[i] - \
            REAL_BOUND_VAL if feature_name not in INTEGER_FEATURES else input_audio_features[
                i] - INTEGER_BOUND_VAL
        upper_bound = input_audio_features[i] + \
            REAL_BOUND_VAL if feature_name not in INTEGER_FEATURES else input_audio_features[
                i] + INTEGER_BOUND_VAL
        feature_conditions.append(f"{feature_name} BETWEEN {
                                  lower_bound} AND {upper_bound}")
    conditions_sql = ' AND '.join(feature_conditions)

    features_sql = ', '.join(features)
    query = f"""
        SELECT s.song_id, s.song_name, s.artist_ids, a.artist_name, a.artist_genres,
               {features_sql}
        FROM songs s
        JOIN artists a ON s.artist_ids = a.artist_id
        WHERE {conditions_sql}
    """
    cursor = conn.cursor()
    cursor.execute(query)
    songs = cursor.fetchall()

    # Filter out inputted IDs and ensure only one song per artist, excluding same artist and song names
    filtered_songs = []
    seen_artists = set()
    seen_song_artist_names = {(info[3], info[1]) for info in inputted_songs}
    for song in songs:
        if song[0] in inputted_ids or (song[3], song[1]) in seen_song_artist_names:
            continue
        artist_id = song[2]
        if artist_id in seen_artists:
            continue
        seen_artists.add(artist_id)
        filtered_songs.append(song)

    # Sort songs by similarity
    filtered_songs.sort(key=lambda song: calculate_similarity(
        song[5:], input_audio_features))
    return filtered_songs


def cbf_cf(ids):
    conn = sqlite3.connect(DB)
    features = ['s.' + feature for feature in CBF_FEATURES]
    songs_info = read_inputted_ids(ids, conn, features)

    with open(OUTPUT_PATH, 'w', encoding='utf-8') as f:
        f.write('INPUTTED IDS\n')
        input_audio_features_list = []
        inputted_ids_set = set(ids)
        song_headers = []
        for idx, song_info in enumerate(songs_info, start=1):
            # song_id, song_name, artist_ids, artist_name, artist_genres
            base_info = song_info[:5]
            audio_features = song_info[5:]
            input_audio_features_list.append(audio_features)
            song_headers.append(
                f"{song_info[3]} - {song_info[1]} | Genres: {song_info[4]}")

            song_id, song_name, artist_ids, artist_name, artist_genres = base_info
            song_url = f"https://open.spotify.com/track/{song_id}"
            features_str = ', '.join(
                [f"{CBF_FEATURES[i]}: {audio_features[i]}" for i in range(len(audio_features))])

            line = (f"{idx}. {song_url} {artist_name} - {song_name} | "
                    f"Genres: {artist_genres} | "
                    f"{features_str}\n")
            f.write(line)

        # SIMILAR AUDIO FEATURES
        f.write('\nSIMILAR AUDIO FEATURES\n')
        for input_audio_features, header in zip(input_audio_features_list, song_headers):
            f.write(f"\n{header}\n")
            similar_songs_info = get_similar_audio_features(
                conn, features, input_audio_features, inputted_ids_set, songs_info)
            for idx, song_info in enumerate(similar_songs_info[:N_RESULT], start=1):
                # song_id, song_name, artist_ids, artist_name, artist_genres
                base_info = song_info[:5]
                audio_features = song_info[5:]

                song_id, song_name, artist_ids, artist_name, artist_genres = base_info
                song_url = f"https://open.spotify.com/track/{song_id}"
                features_str = ', '.join(
                    [f"{CBF_FEATURES[i]}: {audio_features[i]}" for i in range(len(audio_features))])

                line = (f"{idx}. {song_url} {artist_name} - {song_name} | "
                        f"Genres: {artist_genres} | "
                        f"{features_str}\n")
                f.write(line)

    conn.close()
    print('Result for', MODEL, 'stored at', OUTPUT_PATH)


if __name__ == "__main__":
    ids = [
        '1BxfuPKGuaTgP7aM0Bbdwr',
        '4xqrdfXkTW4T0RauPLv3WA',
        '7JIuqL4ZqkpfGKQhYlrirs',
        '5dTHtzHFPyi8TlTtzoz1J9',
    ]
    cbf_cf(ids)
